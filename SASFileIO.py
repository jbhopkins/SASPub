'''
Created on Sept 28, 2019

@author: Jesse Hopkins

#******************************************************************************
# This file is part of SASPub.
#
#    SASPub is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    SASPub is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with SASPub.  If not, see <http://www.gnu.org/licenses/>.
#
#******************************************************************************

This file contains basic functions for processing on one more or scattering profile,
including averaging, subtracting, and merging.
'''

from __future__ import absolute_import, division, print_function, unicode_literals
from builtins import object, range, map
from io import open

if __name__ == "__main__" and __package__ is None:
    __package__ = "SASPub"

import os.path
import re

import numpy as np

import Data

def load_files(filenames):
    loaded_data = []

    for filename in filenames:
        ext = os.path.splitext(filename)

        if ext in text_types:
            data = load_text(filename)
        elif ext in series_types:
            data = load_series(filename)
        else:
            data = load_text(filename)

        if data is None:
            if ext in text_types:
                data = load_series(filename)
            elif ext in series_types:
                data = load_text(filename)
            else:
                data = load_series(filename)

        if data is not None:
            data.filename = filename
            data.short_filename = os.path.basename(filename)
            loaded_data.append(data)

    return loaded_data

def load_text(filename):
    ext = os.path.splitext(filename)

    loaders = text_loaders.keys()

    loaded = False

    if ext in loaders:
        loaders.insert(0, loaders.pop(loaders.index(ext)))
        

    for ftype in loaders:
        data = text_loaders[ftype](filename)

        if data is not None:
            break

    return data

def load_dat_file(filename):
    ''' Loads a .dat format file '''

    iq_pattern = re.compile('\s*\d*[.]\d*[+eE-]*\d+\s+-?\d*[.]\d*[+eE-]*\d+\s+\d*[.]\d*[+eE-]*\d+\s*')

    i = []
    q = []
    err = []

    with open(filename, 'rU') as f:
        lines = f.readlines()

    if len(lines) == 0:
        raise SASExceptions.UnrecognizedDataFormat('No data could be retrieved from the file.')

    comment = ''
    line = lines[0]
    j=0
    while line.split() and line.split()[0].strip()[0] == '#':
        comment = comment+line
        j = j+1
        line = lines[j]

    fileHeader = {'comment':comment}
    parameters = {'filename' : os.path.split(filename)[1],
                  'counters' : fileHeader}

    if comment.find('model_intensity') > -1:
        #FoXS file with a fit! has four data columns
        is_foxs_fit=True
        imodel = []
    else:
        is_foxs_fit = False

    for line in lines:
        iq_match = iq_pattern.match(line)

        if iq_match:
            if not is_foxs_fit:
                found = iq_match.group().split()
                q.append(float(found[0]))
                i.append(float(found[1]))
                err.append(float(found[2]))
            else:
                found = line.split()
                q.append(float(found[0]))
                i.append(float(found[1]))
                imodel.append(float(found[2]))
                err.append(float(found[3]))


    #Check to see if there is any header from RAW, and if so get that.
    header = []
    for j in range(len(lines)):
        if '### HEADER:' in lines[j]:
            header = lines[j+1:]

    hdict = None

    if len(header)>0:
        hdr_str = ''
        for each_line in header:
            hdr_str=hdr_str+each_line.lstrip('#')
        try:
            hdict = dict(json.loads(hdr_str))
            # print 'Loading RAW info/analysis...'
        except Exception:
            # print 'Unable to load header/analysis information. Maybe the file was not generated by RAW or was generated by an old version of RAW?'
            hdict = {}


    if len(i) > 0:
        i = np.array(i)
        q = np.array(q)
        err = np.array(err)

        if is_foxs_fit:
            imodel = np.array(imodel)

        if hdict:
            for each in hdict.iterkeys():
                if each != 'filename':
                    parameters[each] = hdict[each]

        if is_foxs_fit:
            profile_data = Data.ProfileData(q, i, err, parameters, q, imodel)
        else:
            profile_data = Data.ProfileData(q, i, err, parameters)

    else:
        profile_data = None


    return profile_data





text_types = ['.txt', '.csv', '.dat', 'rad', '.int', '.fit']
series_types = ['.sec']

text_loaders = {'.dat'  : load_dat_file,
    }

